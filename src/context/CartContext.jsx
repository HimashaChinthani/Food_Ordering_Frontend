import React, { createContext, useContext, useEffect, useState } from 'react';

const CartContext = createContext();

export const useCart = () => useContext(CartContext);

export const CartProvider = ({ children }) => {
  const [items, setItems] = useState(() => {
    try {
      const raw = localStorage.getItem('cart');
      return raw ? JSON.parse(raw) : [];
    } catch (e) {
      return [];
    }
  });

  useEffect(() => {
    try { localStorage.setItem('cart', JSON.stringify(items)); } catch(e){}
  }, [items]);

  const add = (item) => {
    setItems(prev => {
      const found = prev.find(p => p.id === item.id);
      if (found) return prev.map(p => p.id === item.id ? { ...p, qty: (p.qty || 1) + 1 } : p);
      return [...prev, { ...item, qty: 1 }];
    });
    // fire-and-forget: send order to backend endpoint when item is added
    trySendOrder(item, 1);
  };

  // Helper: send a minimal order to the backend. Non-blocking and best-effort.
  const ORDER_API = 'http://localhost:8082/api/v3/addorder';

  async function trySendOrder(item, qty = 1) {
    if (!item) return;
    try {
      // prefer the logged-in `user` object stored by the app
      let customerName = 'Guest';
      let customerEmail = '';
      try {
        const rawUser = localStorage.getItem('user');
        if (rawUser) {
          const u = JSON.parse(rawUser);
          customerName = u.name || u.fullName || u.username || customerName;
          customerEmail = u.email || u.username || customerEmail;
        }
      } catch (e) {
        // fallback to older keys if present
        customerName = localStorage.getItem('customerName') || customerName;
        customerEmail = localStorage.getItem('customerEmail') || customerEmail;
      }

      const orderPayload = {
        // orderId is generated by backend DB
        customerName,
        customerEmail,
        status: 'PENDING',
        totalAmount: (parseFloat(item.price) || 0) * qty,
        orderDate: new Date().toISOString(),
        items: JSON.stringify([{ id: item.id ?? item._id ?? item.menuId, name: item.name, price: item.price, qty }])
      };

      // send request but do not block UI
      fetch(ORDER_API, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(orderPayload),
      }).then(async res => {
        if (!res.ok) {
          const text = await res.text().catch(() => '');
          console.warn('Order API responded with error', res.status, text);
        } else {
          // server created order - you can inspect response if needed
          const data = await res.json().catch(() => null);
          console.log('Order created', data);
        }
      }).catch(err => {
        console.warn('Failed to send order to backend', err.message || err);
      });
    } catch (err) {
      console.warn('trySendOrder error', err);
    }
  }
  const remove = (item) => setItems(prev => prev.filter(p => p.id !== item.id));
  const changeQty = (item, qty) => setItems(prev => prev.map(p => p.id === item.id ? { ...p, qty } : p));
  const clear = () => setItems([]);

  const value = { items, add, remove, changeQty, clear };
  return <CartContext.Provider value={value}>{children}</CartContext.Provider>;
};

export default CartContext;
